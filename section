#!/usr/bin/env ruby

require 'net/http'
require 'fileutils'
require 'tempfile'
require 'open-uri'
require 'rubygems/package'
require 'json'
require 'open3'
require 'logger'

STDOUT.sync = true

TAR_LONGLINK = '././@LongLink'

SECTION_CLI_PATH = File.expand_path(File.dirname(__FILE__))
VAGRANT_PATH = File.join(SECTION_CLI_PATH, "vagrant")
APPS_PATH = File.join(SECTION_CLI_PATH, "apps")
INSTANCE_TOKEN_FILE = File.join(VAGRANT_PATH, 'hiera', 'instance_token')
INSTANCE_CONFIG_FILE = File.join(VAGRANT_PATH, 'hiera', 'config.json')
REPOSITORY_PATH_FILE = File.join(VAGRANT_PATH, 'hiera', 'repository_path')
APP_ID_FILE = File.join(VAGRANT_PATH, 'hiera', 'app_id')
ENV_ID_FILE = File.join(VAGRANT_PATH, 'hiera', 'env_id')
REPOSITORIES_DIR = File.join(VAGRANT_PATH, 'hiera', 'repos')
APERTURE_DOMAIN = ENV['APERTURE_DOMAIN'] || 'aperture.section.io'
APERTURE_SCHEME = ENV['APERTURE_SCHEME'] || 'https'
SECTION_IO_THUMBPRINT_SHA1 = 'dcf837d21228e3e4c9a4293aabbf1d14e4d6c01a'
SECTION_IO_THUMBPRINT_SHA1_LEGACY = '0dea50cf4cfd5d9c031e265106214065f0d3f7b3'
SECTION_DATA_DIR = File.expand_path('~/.section')
FileUtils.mkdir_p SECTION_DATA_DIR
SECTION_CLI_UPDATE_FILE = File.join(SECTION_DATA_DIR, 'last-update')
SECTION_TARBALL_URL = ENV['SECTION_TARBALL_URL'] || 'http://s3-ap-southeast-2.amazonaws.com/section/section-delivery/localdev.tar.gz'
$git_executable_path = nil
$git_version = nil

@logger = Logger.new(STDERR)
@logger.level = ENV['SECTION_DEBUG'] == 'true' ? Logger::DEBUG : Logger::INFO
@logger.formatter = proc do |severity, datetime, progname, msg|
  "#{datetime} [#{severity}]: #{msg}\n"
end
@logger.debug "SECTION_CLI_PATH is '#{SECTION_CLI_PATH}'"

def display_command_options()
  puts "\n Options:\n"
  puts "   * up <token> - Bring up a new section virtual machine for the specified instance token\n"
  puts "   * init <token> - Make the application for the specified instance token the current application./\n"
  puts "   * status - Show the git status for your current local application repository\n"
  puts "   * reload - Reload local proxy stack with your changes\n"
  puts "   * pull - Pull down any updates commited to your git repository\n"
  puts "   * push <commit message> - Commit and push local changes to your git repository\n"
  puts "   * promote - Merge the current branch into Production and push result to your git repository\n"
  puts "   * --help - Display this help content\n"

  puts "\n Documentation can be found at https://www.section.io/docs/cli/\n"
  puts "\n Submit any support questions to https://support.section.io or support@section.io"
end

def get_user_agent()

  exit_status, section_commit = cmd_execute(SECTION_CLI_PATH, 'git rev-parse --short HEAD')
  # NOTE section_commit will be wrong if we `git pull SECTION_CLI_PATH` before we run this code
  result = "section.cli/#{section_commit}"

  result += " #{RUBY_ENGINE}/#{RUBY_VERSION} (#{RUBY_PLATFORM})"

  exit_status, vagrant_version = cmd_execute(SECTION_CLI_PATH, 'vagrant --version')
  if exit_status == 0
    vagrant_version.sub!(/^vagrant\s*/i, '')
    result += " vagrant/#{vagrant_version}"
  end

  result += " git/#{$git_version}"

  # TODO SSH version

  return result
end

def get_instance_config(token)
  uri = URI.parse("#{APERTURE_SCHEME}://#{APERTURE_DOMAIN}/instance/getconfig?token=#{token}")
  @logger.debug "get_instance_config uri is '#{uri}'"

  http = Net::HTTP.new(uri.host, uri.port)
  if 'https' == APERTURE_SCHEME
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_PEER
    http.verify_callback = lambda do |preverify_ok, ssl_context|
      thumbprint = OpenSSL::Digest::SHA1.new(ssl_context.chain[0].to_der).to_s
      @logger.debug "TLS certificate thumbprint is '#{thumbprint}'"
      return true if thumbprint == SECTION_IO_THUMBPRINT_SHA1
      return true if thumbprint == SECTION_IO_THUMBPRINT_SHA1_LEGACY
      return false
    end
  end
  config_str = http.get(uri, { 'User-Agent' => get_user_agent()}).body
  config = JSON.parse(config_str)
  File.open(INSTANCE_CONFIG_FILE, 'w+') {|f| f.write(config_str) }
  return config
end

def get_local_instance_config()
  if not File.exist?(INSTANCE_CONFIG_FILE)
    puts "No local config file, loading from aperture"
    if File.exist?(INSTANCE_TOKEN_FILE) then
      token = IO.read(INSTANCE_TOKEN_FILE)
      print "Running with existing token '#{token}'\n"
      config = get_instance_config(token)
    else
      print "Unable to read the local config file, please run section up with your instance token"
    end
  else
    config_str = IO.read(INSTANCE_CONFIG_FILE)
    config = JSON.parse(config_str)
  end

  return config
end


# Cross-platform way of finding an executable in the $PATH.
#  From: http://stackoverflow.com/a/5471032/20819
#   which('ruby') #=> /usr/bin/ruby
def which(cmd)
  exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']
  ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
    exts.each { |ext|
      exe = File.join(path, "#{cmd}#{ext}")
      return exe if File.executable?(exe) && !File.directory?(exe)
    }
  end
  return nil
end

def download_latest_vagrant_if_needed()

  print "Downloading latest vagrant files to #{VAGRANT_PATH}\n"

  uri = URI.parse(SECTION_TARBALL_URL)
  filename = File.basename(uri.path)
  download_file = File.join(SECTION_CLI_PATH, filename)

  destination = SECTION_CLI_PATH

  source = open(uri)
  Gem::Package::TarReader.new( Zlib::GzipReader.new(source) ) do |tar|
    dest = nil
    tar.each do |entry|
      if entry.full_name == TAR_LONGLINK
        dest = File.join destination, entry.read.strip
        next
      end
      dest ||= File.join destination, entry.full_name
      if entry.directory?
        FileUtils.rm_rf dest unless File.directory? dest
        FileUtils.mkdir_p dest, :mode => entry.header.mode, :verbose => false
      elsif entry.file?
        FileUtils.mkdir_p File.dirname(dest), :verbose => false
        FileUtils.rm_rf dest unless File.file? dest
        File.open dest, "wb" do |f|
          f.print entry.read
        end
        FileUtils.chmod entry.header.mode, dest, :verbose => false
      elsif entry.header.typeflag == '2' #Symlink!
        File.symlink entry.header.linkname, dest
      end
      dest = nil
    end
  end
end

def update_app_repo_dir(config)

  index = 0
  while index < config['accounts'][0]['applications'].length do

    applicationConfig = config['accounts'][0]['applications'][index]
    environmentConfig = applicationConfig['environments'][0]
    application_name = applicationConfig['name']
    $stdout.write "Processing application: #{application_name}\n"
    filefriendlyAppName = application_name.gsub(/[^a-z0-9_\.\-]+/,'_').downcase
    appDirectory = File.join(APPS_PATH, filefriendlyAppName)
    section_config_json_file = File.join(appDirectory, 'section.config.json')

    if (index == 0)
      #For the first application, collect the state files as this is the app that has section up run and will have command like push and pull run against it
      File.open(REPOSITORY_PATH_FILE, 'w+') {|f| f.write(appDirectory) } #Write the path to the current repository
      File.open(APP_ID_FILE, 'w+') {|f| f.write(applicationConfig['application_id']) } #Write the current app id
      File.open(ENV_ID_FILE, 'w+') {|f| f.write(environmentConfig['environment_id']) } #Write the current env id
    end

    if Dir.exist?(appDirectory)
      if File.exist?(section_config_json_file)
        #Leave it in intact
        $stdout.write "Repository exists and will not be altered\n"
      else
        abort "Unknown state, cannot continue. Missing file #{section_config_json_file}"
      end
    else
      $stdout.write "Creating repository\n"
      FileUtils.mkdir_p appDirectory
      gitCmd = "git clone \"#{applicationConfig['repository']}\" #{filefriendlyAppName}"
      clone_succeeded = cmd_execute_interactive(APPS_PATH, gitCmd)
      if not clone_succeeded
        Dir.rmdir appDirectory
        abort "Could not clone #{applicationConfig['repository']}"
      end
    end

    hook_target = File.join(appDirectory, ".git/hooks/pre-commit")
    if not File.exist?(hook_target)
      File.link(File.join(SECTION_CLI_PATH, 'git-hooks-pre-commit'), hook_target)
      File.chmod(0755, hook_target)
    end

    File.open("#{REPOSITORY_PATH_FILE}.app.#{applicationConfig['application_id']}", 'w+') {|f| f.write(appDirectory) } #Write the path to the repository here

    index +=1
  end

end

def validate_section_config_json()
  repo_dir = IO.read(REPOSITORY_PATH_FILE)
  json_file = File.join(repo_dir, 'section.config.json')
  begin
    JSON.parse(IO.read(json_file))
  rescue JSON::ParserError => err
    error_detail = err.message[0, 80]
    error_detail += '...' if err.message.length > 80
    abort "Error Could not parse JSON file '#{json_file}':\n#{error_detail}"
  end
end

def get_repo_dirname(app_id, env_id)
  if !app_id
    app_id = IO.read(APP_ID_FILE)
  end

  if !env_id
    env_id = IO.read(ENV_ID_FILE)
  end

  dest_dirname = "app#{app_id}-env#{env_id}"
  return dest_dirname
end

def copy_app_repo_to_hiera(config)
  #sync apps\friendlyname to C:\squixa\section.cli\vagrant\hiera\repos\<N>

  config['accounts'][0]['applications'].each do |applicationConfig|
    source_dir = IO.read("#{REPOSITORY_PATH_FILE}.app.#{applicationConfig['application_id']}")
    dest_dir = File.join(REPOSITORIES_DIR, get_repo_dirname(applicationConfig['application_id'], applicationConfig['environments'][0]['environment_id']))
    @logger.debug "Copying #{source_dir} to #{dest_dir}\n"
    FileUtils.mkdir_p dest_dir
    FileUtils.cp_r(File.join(source_dir, "."), dest_dir, :remove_destination=>true)
  end
end

def copy_app_repo_to_volume_source(config)

  container_volume_repo_path = File.join('/opt/section.delivery/hiera/repos/')

  ssh_cmd = []

  config['accounts'][0]['applications'].each do |applicationConfig|
    vagrant_mapped_repo_path = File.join('/vagrant/hiera/repos/', get_repo_dirname(applicationConfig['application_id'], applicationConfig['environments'][0]['environment_id']))

    ssh_cmd.push("sudo rsync -a --delete --delete-during --delete-excluded --exclude .git #{vagrant_mapped_repo_path} #{container_volume_repo_path}")

    ssh_cmd.push("sudo /vagrant/remove-containers-if-proxystack-changed.sh #{applicationConfig['application_id']} #{applicationConfig['environments'][0]['environment_id']}")
  end

  vagrant_execute('ssh', ['-c', ssh_cmd.join(" && ")])
end

if ! which('vagrant')
  puts 'Vagrant must be installed and on the PATH. Vagrant can be downloaded at https://www.vagrantup.com/'
  exit 1
end

def section_init()

  # update section cli if not attempted for more than an hour, or if forced by environment variable
  @logger.debug "SECTION_CLI_UPDATE_FILE is '#{SECTION_CLI_UPDATE_FILE}'"
  update_section_cli_now = !File.exists?(SECTION_CLI_UPDATE_FILE) || File.mtime(SECTION_CLI_UPDATE_FILE) < (Time.now - 60*60)
  @logger.debug "File-derived value for update_section_cli_now is #{update_section_cli_now}"
  update_section_cli_now = (ENV['SECTION_CLI_UPDATE'] == 'true') if ENV['SECTION_CLI_UPDATE'] # force either on or off
  @logger.debug "Environment-overridden value for update_section_cli_now is #{update_section_cli_now}"
  if update_section_cli_now
    exit_status, stdout, stderr = cmd_execute(SECTION_CLI_PATH, "git pull")
    exit_status==0 or $stderr.write "Warning: could not check for update to latest version of section.cli\n"
    FileUtils.touch SECTION_CLI_UPDATE_FILE
  end

  #TODO: Allow a command line arg to force a reload
  #if not File.directory?(VAGRANT_PATH)
    download_latest_vagrant_if_needed()
  #end

  if ARGV[1] != nil then
    FileUtils.mkdir_p File.join(VAGRANT_PATH, 'hiera') #, :verbose => false
    token = ARGV[1]

    File.open(INSTANCE_TOKEN_FILE, 'w+') {|f| f.write(ARGV[1]) }
  elsif File.exist?(INSTANCE_TOKEN_FILE) then
    token = IO.read(INSTANCE_TOKEN_FILE)
    print "Running with existing token '#{token}'\n"
  else
    $stderr.write "Error: Please provide your instance token as a parameter\n"
    $stderr.write "ie. \n\tsection up <token>\n\n"
    abort "You can obtain the instance token by logging in to aperture.section.io and selecting the instance you are trying to launch\n"
  end

  config = get_instance_config(token)
  update_app_repo_dir(config)
  copy_app_repo_to_hiera(config)
end

def cmd_execute(path, cmd)
  Open3.popen3(cmd, :chdir=>path) {|stdin, stdout, stderr, wait_thr|
    @logger.debug "Running [#{path}] #{cmd}"

    exit_status = wait_thr.value # Process::Status object returned.
    stdout_result = stdout.read.chomp
    stderr_result = stderr.read.chomp

    @logger.debug "exit_status: #{exit_status}"
    @logger.debug "stdout: "+stdout_result
    @logger.debug "stderr: "+stderr_result
    return exit_status, stdout_result, stderr_result
  }
end

def cmd_execute_interactive(path, cmd)
  @logger.debug "Running [#{path}] #{cmd}"
  return system(cmd, :chdir => path)
end

def vagrant_execute(subcommand, args = [])
  @logger.debug "Running Vagrant #{subcommand} with args: #{args}"
  all_args = [subcommand].concat(args)
  system({ 'PATH' => @vagrant_env_path }, 'vagrant', *all_args, :chdir => VAGRANT_PATH)
end

def get_branch_name()

  repo_path = IO.read(REPOSITORY_PATH_FILE)

  branch = nil
  exit_status, stdout, stderr = cmd_execute(repo_path, "git rev-parse --abbrev-ref HEAD")
  exit_status==0 or abort 'Could\'t check for clean git working copy'
  stdout.length!=0 or abort 'Couldn\'t determine current HEAD'
  branch = stdout

  return branch
end

def section_promote()
  destination_branch='Production'

  repo_path = IO.read(REPOSITORY_PATH_FILE)

  #Get current branch name
  original_branch = get_branch_name()

  #Set source branch name to current branch name
  source_branch=original_branch

  #Check that we're not already on the Production branch
  source_branch != destination_branch or abort "Already on the #{destination_branch} branch, just use `section push`"

  #Check that there are no local changes
  exit_status, stdout, stderr = cmd_execute(repo_path, "git status --porcelain")
  exit_status==0 or abort 'Could\'t check for clean git working copy'
  stdout.length==0 or abort '"section push" or discard changes before continuing.'

  #Push current branch
  cmd_execute_interactive(repo_path, "git push origin") or abort 'Failed to push current branch'

  #Checkout destination branch
  cmd_execute(repo_path, "git checkout #{destination_branch}") or abort "Couldn't checkout #{destination_branch}"

  #Pull destination branch
  cmd_execute_interactive(repo_path,"git pull") or abort "Couldn't update #{destination_branch}"

  #Merge source branch into destination branch
  cmd_execute(repo_path,"git merge --no-ff -m \"#{source_branch} merged to #{destination_branch}\" #{source_branch}") or exit

  #Push destination branch
  cmd_execute_interactive(repo_path, "git push") or exit

  #Checkout original branch
  cmd_execute(repo_path,"git checkout #{original_branch}") or exit

end #section_promote

def section_status()
  git_path = IO.read(REPOSITORY_PATH_FILE)
  gitCmd = "git status"

  puts("[#{git_path}] #{gitCmd}")
  exit_status, stdout, stderr = system(gitCmd, :chdir => git_path)
  puts(stdout)
end

def ensure_git_valid()
  $git_executable_path = which('git')

  if not $git_executable_path
    puts 'git must be installed and on the PATH.'
    exit 1
  end

  exit_status, $git_version, std_err = cmd_execute(SECTION_CLI_PATH, 'git --version')
  if exit_status == 0
    $git_version.sub!(/^git\s+version\s*/i, '')
    $git_version_parts = $git_version.split('.') unless not $git_version

    if (not $git_version_parts or $git_version_parts[0].to_i < 2)
      puts "git version 2.0 or greater is required, currently installed version is #{$git_version}"
      exit 1
    end
  else
    puts "Unable to obtain git version, error when running `git --version`: #{std_err}"
    exit exit_status
  end

end
ensure_git_valid()

def ensure_ssh_on_vagrant_path ()
  @vagrant_env_path = ENV['PATH'].dup

  return if which('ssh')

  # check for ssh in git directory for Windows
  try_ssh_directory_paths = [
    File.dirname($git_executable_path),
    File.join(File.dirname($git_executable_path), '..', 'bin'),
    File.join(File.dirname($git_executable_path), '..', 'usr', 'bin'),
  ]

  try_ssh_directory_paths.each do |try_ssh_directory_path|
    if File.executable?(File.join(try_ssh_directory_path, 'ssh.exe'))
      @vagrant_env_path << File::PATH_SEPARATOR + try_ssh_directory_path
      return
    end
  end


  puts 'SSH must be installed and on the PATH.' # TODO recommend an OS-specific source for SSH
  exit 1
end
ensure_ssh_on_vagrant_path

# TODO report all missing dependencies before exiting for a better user experience

# TODO test for VirtualBox installation

case ARGV[0]
when "init"

  section_init

when "up"

  section_init

  vagrant_execute('up')
  vagrant_execute('ssh', ['-c', 'sudo /vagrant/remove-appid-only-artifacts.sh && sudo /vagrant/bootstrap.sh;'])

when "reload"
  validate_section_config_json()
  vagrant_execute('ssh', ['-c', 'sudo /vagrant/remove-appid-only-artifacts.sh;'])
  config = get_local_instance_config()
  copy_app_repo_to_hiera(config)
  copy_app_repo_to_volume_source(config)

  app_id = IO.read(APP_ID_FILE)

  #TODO remove this step, local reload should not contact the Internet
  vagrant_execute('ssh', ['-c', "sudo /vagrant/hiera/generate_hiera.sh && sudo /vagrant/run-puppet.sh && sudo /vagrant/update_containers.sh #{app_id};"])

  #TODO test the exit codes of the above commands before declaring success
  puts "section.io proxy stack updated with the latest changes\n"

when "pull"

  git_path = IO.read(REPOSITORY_PATH_FILE)
  gitCmd = "git pull"
  puts("[#{git_path}] #{gitCmd}")

when 'status'

  #NOTE: This will be deprecated by working directory context project
  section_status


when 'push'

  if ARGV[1] == nil or ARGV[1] == "" then
    abort "*** Missing commit message ***\n\nUsage: \n\tsection push \"Commit message\""
  end

  commit_message = ARGV[1]
  git_path = IO.read(REPOSITORY_PATH_FILE)

  gitCmd = "git add ."
  puts("[#{git_path}] #{gitCmd}")
  system(gitCmd, :chdir => git_path)

  gitCmd = "git commit -m \"#{commit_message}\""
  puts("[#{git_path}] #{gitCmd}")
  system(gitCmd, :chdir => git_path)

  gitCmd = "git push"
  puts("[#{git_path}] #{gitCmd}")
  system(gitCmd, :chdir => git_path)

when 'promote'
  section_promote

when '--help'

  display_command_options()

when nil
  puts "\nERROR: Missing command\n"
  display_command_options()
  exit 1

else
  puts "\nERROR: Invalid command '#{ARGV[0]}'"
  display_command_options()
  exit 1
end
